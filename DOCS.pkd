---
name: doc
text_format: markdown
generator: src:nushell

---
- name: doc
  summary: |-
    Returns a summarized table of available symbols in the
    currently selected doctable.
  kind: command
  description: |-
    Returns a summarized table of available symbols in the
    currently selected doctable.

    If a `string` is passed as an argument, doctable will be
    filtered by `name` and `summary`. If an `int` is passed
    as an argument, only the selected symbol is presented.
    If a closure is passed as an argument, it'll be used to
    filter the full doctable before being summarized and paged.

    ### Examples:
    ```nushell
    # Return list of all symbols in current doctable
    > doc

    # Filter symbols by name in current doctable
    > doc 'add'

    # Show symbol at index 3
    > doc 3

    # Filter symbols by namespace
    > doc {|| where ns == 'inspect'}

    # Show symbols that are either functions or classes
    > doc {|| where kind in ['function', 'class']}

    # Show symbols that have a summary
    > doc {|| where summary != ''}
    ```
  source: |-
    def doc [ query?: any ] {
      if (('PKD_CURRENT' in $env) != true) {
        print "No docfile currently selected. Type `doc use <path>` to select a docfile to use."
        return
      }
      if (($query|describe) == 'int') {
        $query|history symbols add

        pkd-doctable|get $query|present
      } else if (($query|describe) == 'closure') {
        pkd-doctable
        |add-doc-ids
        |do $query
        |summarize-all
        |present-list
      } else if ($query != null) {
        let query = ($query|str downcase)
        let search = (
          pkd-doctable
          |add-doc-ids
          |find $query -c ['name', 'summary']
        )

        $search
        |insert dist {|row| (
          (($row.name|ansi strip|str downcase|str index-of $query|if ($in == -1) { 100 } else { $in }) * 100) +
          (($row.name|ansi strip|str distance $query)) * 100 +
          (($row.summary?|default ''|ansi strip|str downcase|find $query|length) * -10) +
          ($row.description?|default ''|ansi strip|str downcase|find $query|length) * -1
        )}
        |sort-by dist
        |reject dist
        |summarize-all
        |present-list
      } else {
        pkd-doctable
        |add-doc-ids
        |summarize-all
        |present-list
      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: query
      type: any
      description: name/index/closure to query for
      optional: true
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc bookmarks
  summary: Shows a summarized list of bookmarked symbols for this doctable
  kind: command
  description: Shows a summarized list of bookmarked symbols for this doctable
  source: |-
    def "doc bookmarks" [] {
      let docs = pkd-doctable|add-doc-ids

      bookmarks current
      |reverse
      |each {|index| $docs|get $index}
      |summarize-all
      |present-list
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc bookmarks add
  summary: Adds $index to the list of bookmarked symbols
  kind: command
  description: Adds $index to the list of bookmarked symbols
  source: |-
    def "doc bookmarks add" [ index: int ] {
      update { append $index|uniq }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: index
      type: int
      description: index of the symbol to bookmark
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc bookmarks clear
  summary: Clears the bookmark list for this doctable
  kind: command
  description: Clears the bookmark list for this doctable
  source: |-
    def "doc bookmarks clear" [] {
      update {|| [] }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc bookmarks current
  summary: Returns the list of bookmarked symbol indices in current doctable
  kind: command
  description: Returns the list of bookmarked symbol indices in current doctable
  source: |-
    def "doc bookmarks current" [] {
      bookmarks|get -i (current-name)|default []
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc bookmarks remove
  summary: Removes $index from the list of bookmarked symbols
  kind: command
  description: Removes $index from the list of bookmarked symbols
  source: |-
    def "doc bookmarks remove" [ index: int ] {
      update { filter { $in != $index }  }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: index
      type: int
      description: index of the symbol to remove
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc cache
  summary: |-
    Returns a list of doctables cached in the local filesystem.
    `cache path` returns the directory used for storing files.
    See `doc cache clear` for details on cache management.
  kind: command
  description: |-
    Returns a list of doctables cached in the local filesystem.
    `cache path` returns the directory used for storing files.
    See `doc cache clear` for details on cache management.
  source: |-
    def "doc cache" [] {
      init
      ls -s (repository)
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc cache clear
  summary: |-
    Clears all locally cached doctables. Useful for updating
    stale documents.
  kind: command
  description: |-
    Clears all locally cached doctables. Useful for updating
    stale documents.

    Calling this manually shouldn't be necessary as pikadoc
    automatically clears old files when cache size surpasses
    `$env.PKD_CONFIG.cacheMaxSize`.

    The default max cache size is 100Mb.

    Examples

    # adjust max cache size
    let pkdConfig = $env.PKD_CONFIG|merge { cacheMaxSize: ('200Mb'|into filesize) }; $env.PKD_CONFIG = $pkdConfig
  source: |-
    def "doc cache clear" [] {
      init

      rm -f ((repository) + '/*'|into glob)
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc cache command-to-id
  summary: Escapes special characters in input command to use it as a valid Unix path
  kind: command
  description: Escapes special characters in input command to use it as a valid Unix path
  source: |-
    def "doc cache command-to-id" [] {
      str replace -a '/' '__'
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc cache init
  summary: Initializes cache
  kind: command
  description: Initializes cache
  source: |-
    def "doc cache init" [] {
      if (not (repository|path exists)) {
        mkdir (repository)
      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc cache repository
  summary: |-
    Returns the path to the cache directory that's currently
    being used.
  kind: command
  description: |-
    Returns the path to the cache directory that's currently
    being used.
  source: |-
    def "doc cache repository" [] {
      $"($env.PKD_CONFIG_HOME)/doc-cache"
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc doctable save
  summary: Saves doctable in the filesystem.
  kind: command
  description: Saves doctable in the filesystem.
  source: |-
    def "doc doctable save" [ filepath: string --format: string --keepFiles ] {
      if ($format == 'yaml') {
        ['---', (pkd-about|to yaml), '---', (
          pkd-doctable|if ($keepFiles) {
            $in
          } else {
            reject -i defined_in
          }
          |to yaml)]
        |str join "\n"
        |save -f $filepath
      } else if ($format == 'md') {
        pkd-doctable
        |each {|symbol|
          let path = $filepath|path join ($symbol.name + '.md')
          $symbol.description|save -f $path
          $path
        }
      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: filepath
      type: string
      description: path to use for saving the file
      optional: false
      default: null
      kind: positional
    - name: format
      type: string
      description: format of the output - supports `yaml` and `md`
      optional: true
      default: yaml
      kind: named
    - name: keepFiles
      type: bool
      description: keep references to local files
      optional: true
      default: null
      kind: flag
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc history
  summary: Shows a summarized list of recently viewed symbols
  kind: command
  description: Shows a summarized list of recently viewed symbols
  source: |-
    def "doc history" [] {
      let docs = pkd-doctable|add-doc-ids

      history symbols
      |reverse
      |each {|index| $docs|get $index}
      |summarize-all
      |present-list
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc history doctables
  summary: Returns a list of the last 50 doctables selected with `doc use`
  kind: command
  description: Returns a list of the last 50 doctables selected with `doc use`
  source: |-
    def "doc history doctables" [] {
      doctables value
      |each {|| $"doc ($in)"}
      |reverse
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc history doctables add
  summary: Adds $in to the doctable history
  kind: command
  description: Adds $in to the doctable history
  source: |-
    def "doc history doctables add" [] {
      let cmd = $in
      doctables set (
        doctables value
        |prepend $cmd
        |uniq
      )
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc history doctables clear
  summary: Deletes the history file
  kind: command
  description: Deletes the history file
  source: |-
    def "doc history doctables clear" [] {
      doctables set []
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc history symbols
  summary: Returns the list of recently viewed symbols
  kind: command
  description: Returns the list of recently viewed symbols
  source: |-
    def "doc history symbols" [] {
      $env.PKD_SYMBOL_HISTORY?|default []
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc history symbols add
  summary: Adds $in to the list of recently viewed symbols
  kind: command
  description: Adds $in to the list of recently viewed symbols
  source: |-
    def "doc history symbols add" [] {
      let idx = $in
      $env.PKD_SYMBOL_HISTORY = (symbols|prepend $idx|uniq)
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc history symbols clear
  summary: Clears the list of recently viewed symbols
  kind: command
  description: Clears the list of recently viewed symbols
  source: |-
    def "doc history symbols clear" [] {
      $env.PKD_SYMBOL_HISTORY = []
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc more
  summary: Shows more results from the last search. If `index` is passed as an argument, the given result will be selected from the last result set and presented as a whole.
  kind: command
  description: |-
    Shows more results from the last search. If `index` is passed as an argument, the given result will be selected from the last result set and presented as a whole.

    Examples

    # Show more results from the last search
      ```doc more```

    # Show result number 8
      ```doc more 8```
  source: |-
    def "doc more" [ index?: int ] {
      if ($index != null) {
        $env.PKD_RESULTS|get ($index)|present
      } else {
        $env.PKD_RESULTS|paginate (result-lines)
      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: index
      type: int
      description: ''
      optional: true
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc pkd-about
  summary: Returns the header section for the currently mounted doctable
  kind: command
  description: Returns the header section for the currently mounted doctable
  source: |-
    def "doc pkd-about" [] {
      $env.PKD_CURRENT.about
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc pkd-config
  summary: Returns configuration value for $name
  kind: command
  description: Returns configuration value for $name
  source: |-
    def "doc pkd-config" [ name: string ] {
      $env.PKD_CONFIG|get $name
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: name
      type: string
      description: ''
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc pkd-doctable
  summary: Returns the body section for the currently mounted doctable
  kind: command
  description: Returns the body section for the currently mounted doctable
  source: |-
    def "doc pkd-doctable" [] {
      $env.PKD_CURRENT.doctable
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc present
  summary: |-
    Presents the symbol passed in as input as tidily formatted output.
    Useful for showing the results of custom queries.
  kind: command
  description: |-
    Presents the symbol passed in as input as tidily formatted output.
    Useful for showing the results of custom queries.

    ### Example:
        ```> doc pkd-doctable|get 0|doc present```
  source: |-
    def "doc present" [] {
      let output = $in
        |trim-record-whitespace

      let trimmedOutput = if ($output.summary? == '' or ($output.summary?|default ''|str trim) ==
          ($output.description?|default ''|str trim)) {
        $output|reject summary? description?
      } else {
        $output|reject description?
      }
      |reject examples?

      let meta = (
        $trimmedOutput
        |maybe-update signatures {|| present-type }
        |insert source_available {|row| $row.source? != null}
        |reject source?
        |table --expand
      )

      if ((pkd-about).text_format? == 'markdown') {
        let body = (
          $output
          |present-body
          |glow -s auto
          |complete
          |get stdout
        )

        $"($meta)\n\n($body)"
      } else {
        $"($meta)\n\n($output.description?)"
      }
      |pager
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc s index
  summary: |-
    Returns a list of doctables available in the pikadoc central repository.
    See `doc s use` for more information.
  kind: command
  description: |-
    Returns a list of doctables available in the pikadoc central repository.
    See `doc s use` for more information.
  source: |-
    def "doc s index" [] {
      index full
      |insert id {|row| $row.path|path basename|str substring ..-4}
      |select name id version? generator
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc s use
  summary: |-
    Mounts doctable with `name` for use from the pikadoc central repository.
    To get a list of available doctables, see `doc s index`.
  kind: command
  description: |-
    Mounts doctable with `name` for use from the pikadoc central repository.
    To get a list of available doctables, see `doc s index`.

    ### Example:
        ```> doc s python~3.13```
  source: |-
    def "doc s use" [ path: string ] {
      do --env $env.DOC_USE {||
        let matches = find-doc $path
        if (($matches|length) != 1) {
          print (
            $matches
            |select name path version? generator
          )
          print $"Found ($matches|length) results when searching for `($path)`"
          print $"Type `doc s $path` to specify results"
          return
        } else {
          let docs = http get ($matches.0.repoUrl)|from yaml

          {
            about: ($docs|get 0)
            doctable: ($docs|get 1)
          }
        }

      } $"s ($path|str downcase)"
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: path
      type: string
      description: path to the file to use, including the version number
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc search
  summary: Searches the descriptions of all symbols in the current doctable for `query`. System grep is used for matching output.
  kind: command
  description: Searches the descriptions of all symbols in the current doctable for `query`. System grep is used for matching output.
  source: |-
    def "doc search" [ query: string ] {
      if (('PKD_CURRENT' in $env) != true) {
        print "No docfile currently selected. Type `doc use <path>` to select a docfile to use."
        return
      }

      pkd-doctable
      |add-doc-ids
      |find ($query) -c ['description']
      |insert ranking {|row| (
        $row.description
        |ansi strip
        |grep -F -i -o $query
        |lines
        |length
      ) * -1}
      |sort-by ranking
      |insert results {|row|
        $row.description
        |grep -F -i $query -A0 -B0 --group-separator='...' -m 5
      }
      |select '#' name results
      |present-list
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: query
      type: string
      description: ''
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:devdocs index
  summary: |-
    Retrieves a list of available documentation files from devdocs.io
    and returns them as a table
  kind: command
  description: |-
    Retrieves a list of available documentation files from devdocs.io
    and returns them as a table
  source: |-
    def "doc src:devdocs index" [] {
      http get https://devdocs.io/docs.json
      |select name slug version? links?.home?
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:devdocs use
  summary: |-
    Downloads and attempts to parse a file downloaded from devdocs.io
    into a doctable. This can be a slow process, so it's best to
    use `doc s` over this when possible. If `options` is passed,
    `$options.stripElements` should be an XPath selector that's used
    to strip unnecessary elements from the HTML input.
  kind: command
  description: |-
    Downloads and attempts to parse a file downloaded from devdocs.io
    into a doctable. This can be a slow process, so it's best to
    use `doc s` over this when possible. If `options` is passed,
    `$options.stripElements` should be an XPath selector that's used
    to strip unnecessary elements from the HTML input.
  source: |-
    def "doc src:devdocs use" [ slug: string options: record = {} ] {
      let metadata = index|where {|| $in.slug == $slug}|get 0?
      let generatorCommand = $"src:devdocs use ($slug) (if ($options != {}) { $options } else { null })"

      if ($metadata == null) {
        print $"Couldn't find devdocs with the slug ($slug)"
      } else {
        do --env $env.DOC_USE {||
          let docs = (format (download $slug) $options)
          {
            about: {
              name: $metadata.name
              slug: $slug
              text_format: 'markdown'
              generator: 'src:devdocs'
              generator_command: 'src:devdocs'
              version: $metadata.version
              copyright: $docs.copyright
              homepage: $metadata.links_home
            },
            doctable: $docs.doctable
          }
        }  $generatorCommand
      }

    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: slug
      type: string
      description: url slug of the documentation to use
      optional: false
      default: null
      kind: positional
    - name: options
      type: record
      description: options for parsing
      optional: true
      default: {}
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:github use
  summary: |-
    Attempts to download and use all available documentation from
    the given GitHub repo using the public API. `repoName` should be
    the name of the repository, including the name of the owner.  If it
    doesn't include the name of the owner, GitHub search API is used to
    select the most popular repo with the given name. If `branchName` is
    not passed an argument, default branch of the project is chosen.
  kind: command
  description: |-
    Attempts to download and use all available documentation from
    the given GitHub repo using the public API. `repoName` should be
    the name of the repository, including the name of the owner.  If it
    doesn't include the name of the owner, GitHub search API is used to
    select the most popular repo with the given name. If `branchName` is
    not passed an argument, default branch of the project is chosen.

    ### Examples:
    ```nushell
    # Use the docs available in the pikadoc GitHub repository
    > doc src:github use ArseAssassin/pikadoc

    # Use the docs available in the nushell GitHub repository
    > doc src:github use nushell
    ```
  source: |-
    def "doc src:github use" [ repoName: string branchName?: string ] {
      do --env $env.DOC_USE {||
        let repo = if ('/' in $repoName) {
          $repoName
        } else {
          http get $"https://api.github.com/search/repositories?q=($repoName)&per_page=1"
          |get items.0.full_name
        }

        let branch = if ($branchName == null) {
          let metadata = http get $"https://api.github.com/repos/($repo)"
          $metadata.default_branch
        } else {
          $branchName
        }

        let fileTree = (
          http get $"https://api.github.com/repos/($repo)/git/trees/($branch)?recursive=true"
          |get tree
        )
        let docs = (
          $fileTree
          |where {|| ($in.path|str ends-with -i '.md') and not ($in.path|str starts-with '.github') and ($in.path|find -i -r 'test.*/') == null}
        )
        let pkds = (
          $fileTree
          |where {($in.path|str ends-with -i '.pkd')}
          |each {|pkd|
            print -n .

            let doc = download-file $repo $branch $pkd.path|from yaml

            $doc.1
            |each {|symbol|
              $symbol|merge { belongs_to: $doc.0.name }
            }
          }
        )

        let mdDoctable = (
          $docs
          |each {|md|
            print -n .

            $md
            |merge {
              doc: (download-file $repo $branch $md.path)
              url: $"https://github.com/($repo)/blob/($branch)/($md.path)"
            }}
            # Disabled for now. GitHub incorrectly reports wiki as enabled for many
            # repositories, causing clone to fail.
            #
            # |if ($metadata.has_wiki) {
            #   $in
            #   |append (do {
            #     let repoPath = "/tmp/" + ($repo|parse '{user}/{name}'|get 0.name) + '.wiki/'

            #     print ''
            #     print $"Repository has wiki enabled, cloning into ($repoPath)"

            #     git -C /tmp/ clone $"https://github.com/($repo).wiki.git"

            #     cd $repoPath
            #     let wikiPages = (
            #       ls **/*.md
            #       |each {|| {
            #         path: $in.name
            #         ns: 'wiki'
            #         url: $"https://github.com/($repo)/wiki/($in.name|str substring ..-3)"
            #         doc: (open $"($repoPath)($in.name)")
            #       }}
            #     )

            #     cd /
            #     rm -rf $repoPath

            #     $wikiPages
            #   })
            # } else {
            #   $in
            # }
            |each {|md| ({
              name: $md.path
              description: $md.doc
              ns: $md.ns?
              kind: 'user guide'
              url: $md.url
              summary: (
                $md.doc
                |pandoc -f gfm -t html --wrap=none
                |hxnormalize -x
                |hxunent -b
                |xmlstarlet select -t --value-of '//p[contains(., '.')][1]'
                |lines
                |each {|| str trim}
                |str join ' '
                |split row '.'
                |get 0
                |str trim
              )
            })}
        )

        {
          about: {
            name: $repo
            text_format: 'markdown'
            generator: 'src:github'
            generator_command: $"src:github ($repoName) ($branchName)"
          }
          doctable: (
            [$mdDoctable, ($pkds|flatten)]|flatten
          )
        }
      } $"src:github use ($repoName) ($branchName)"
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: repoName
      type: string
      description: name of the repo, including the owner
      optional: false
      default: null
      kind: positional
    - name: branchName
      type: string
      description: name of the branch
      optional: true
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:jsdoc is-jsdoc-module
  summary: |-
    Attempts to detect whether given path contains any jsdoc annotations
    in .js files.
  kind: command
  description: |-
    Attempts to detect whether given path contains any jsdoc annotations
    in .js files.
  source: |-
    def "doc src:jsdoc is-jsdoc-module" [ path: string ] {
      cd $path
      (grep -qs '\\* @' **/*.js -m1 --exclude-dir=*.js|complete|get exit_code) == 0
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: path
      type: string
      description: ''
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:jsdoc use
  summary: |-
    Parses doctable using `jsdoc -X`. For more details on how jsdoc is invoked, you can run:
    `less $"($env.PKD_HOME)/doc/jsdoc-run"`
  kind: command
  description: |-
    Parses doctable using `jsdoc -X`. For more details on how jsdoc is invoked, you can run:
    `less $"($env.PKD_HOME)/doc/jsdoc-run"`

    ### Examples:
    ```nushell
    # Mount jsdocs for ramda.js
    > doc src:jsdoc use node_modules/ramda/src/
    ```
  source: |-
    def "doc src:jsdoc use" [ filepath: string ] {
      if (not (is-jsdoc-module $filepath)) {
        return $"($filepath) doesn't seem to be a jsdoc module. See `doc src:jsdoc is-jsdoc-module` for details"
      }

      let absolutePath = $filepath|path expand
      let generatorCommand = $"src:jsdoc use ($absolutePath|to nuon)"
      do --env $env.DOC_USE {{
        about: {
          name: $filepath
          text_format: 'markdown'
          generator: 'src:jsdoc'
          generator_command: $generatorCommand
          language: 'javascript'
        }
        doctable: (do $env.PKD_CONFIG.npxCommand '--yes' 'jsdoc' '-X' '-r' $absolutePath|parse-from-jsdoc)
      }} $generatorCommand
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: filepath
      type: string
      description: path to the directory jsdoc should be run against
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:man use
  summary: Parses a man page and selects it as the current doctable.
  kind: command
  description: |-
    Parses a man page and selects it as the current doctable.

    Takes the name of the manual entry as an argument and parses the command line options for that entry. The generated doctable is selected as the current doctable.

    ### Examples:
    ```nushell
    > doc src:man use "cat"
    ```
  source: |-
    def "doc src:man use" [ it: string ] {
      let generatorCommand = $"src:man use ($it)"
      do --env $env.DOC_USE {{
        about: {
          name: $it
          text_format: 'plain'
          generator: 'src:man'
          generator_command: $generatorCommand
        }
        doctable: (man -Rutf8 $it|do {groff -man -T utf8}|complete|get stdout|parse)
      }} $generatorCommand
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: it
      type: string
      description: name of the man page
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:npm use
  summary: |-
    Generates doctable for npm package $packageName. Parses .md files
    found in the package repository and attempts to parse jsdocs
    if available.
  kind: command
  description: |-
    Generates doctable for npm package $packageName. Parses .md files
    found in the package repository and attempts to parse jsdocs
    if available.

    ### Examples:
    ```nushell
    # Generate docs for ramda.js npm package
    > doc src:npm use ramda

    # Generate docs for an old version
    > doc src:npm use ramda@0.29.1
    ```
  source: |-
    def "doc src:npm use" [ packageName: string ] {
      let package = if (not ('@' in $packageName) and ('package.json'|path exists)) {
        let packageJson = open 'package.json'
        let dependencies = $packageJson.devDependencies|merge $packageJson.dependencies

        if ($packageName in $dependencies) {
          $"($packageName)@($dependencies|get $packageName)"
        }
      } else {
        $packageName
      }
      let generatorCommand = $"src:npm use ($package|to nuon)"
      do --env $env.DOC_USE {
        let tempProject = '/tmp/pikadoc-npm'
        let packageName = $package|split row '@'|first

        mkdir $tempProject
        cd $tempProject

        let install = (
          do $env.PKD_CONFIG.npmCommand "install" "--no-save" $package
          |complete
        )

        if ($install.exit_code != 0) {
          print $install
          print "Something went wrong during npm install"
          return
        }
        cd ("node_modules"|path join $packageName)

        let packageMeta = open package.json
        let mainDir = $packageMeta.main?|default '.'|path dirname

        {
          about: {
            name: $packageMeta.name
            version: $packageMeta.version
            text_format: 'markdown'
            generator: 'src:npm'
            generator_command: $generatorCommand
            language: 'javascript'
            license: (
              open (
                ['LICENSE', 'LICENSE.md', 'LICENSE.txt']
                |where {path exists}
                |first
              )
            )
          }
          doctable: ((
            ls **/*.md
            |each {
              let file = $in.name
              let md = (open $file)

              {
                name: $file
                kind: 'user guide'
                defined_in: {
                  file: ($file|path expand)
                }
                description: $md
                summary: ($md|helpers markdown-to-summary)
              }
            }
          ) ++ (if (src:jsdoc is-jsdoc-module $mainDir) {
            do {||
              src:jsdoc use $mainDir
              $env.PKD_CURRENT.doctable
            }
          } else {
            []
          }))
        }
      } $generatorCommand

    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: packageName
      type: string
      description: package name, including version
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:nushell use
  summary: Generates doctable from nushell module with `name` and selects it as the current doctable
  kind: command
  description: |-
    Generates doctable from nushell module with `name` and selects it as the current doctable

    Example: doc src:nushell use "doc"
  source: |-
    def "doc src:nushell use" [ name: string ] {
      do --env $env.DOC_USE {
        about: {
          name: $name
          text_format: 'markdown'
          generator: 'src:nushell'
        }
        doctable: (document-module $name)
      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: name
      type: string
      description: the name of the module to document
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:openapi parse-from-swagger
  summary: Returns documentation for a REST endpoint defined in a .json/.yaml file.
  kind: command
  description: |-
    Returns documentation for a REST endpoint defined in a .json/.yaml file.

    `in` is a record parsed from a valid Swagger .json/.yaml file

    Example: http get 'https://petstore.swagger.io/v2/swagger.json'|doc src:openapi parse-from-swagger
  source: |-
    def "doc src:openapi parse-from-swagger" [] {
      let $doc = $in

      ($doc|get paths|items {|path, def|
        [
          (parse-from-path GET $path $def.get?)
          (parse-from-path POST $path $def.post?)
        ]|filter {|| $in != null}
      }|flatten) ++ (
        $doc
        |get definitions
        |items {|name, def|
          {
            name: $name,
            kind: 'schema'
            namespace: definitions
            parameters: ($def.properties|items {|name, param| {
              name: $name,
              type: (normalize-type $param)
              subtypes: (normalize-subtypes $param)
              examples: ($param.example?|if ($in != null) {
                [$in]
              })
            }})
          }
        }
      )
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:openapi use
  summary: Generates doctable from `url` to a valid Swagger .json/.ymal file and selects it as the current doctable
  kind: command
  description: |-
    Generates doctable from `url` to a valid Swagger .json/.ymal file and selects it as the current doctable

    `url` is fetched using a GET request

    Example: doc src:openapi use "https://petstore.swagger.io/v2/swagger.json"
  source: |-
    def "doc src:openapi use" [ url: string ] {
      let generatorCommand = $"src:openapi use ($url)"
      do --env $env.DOC_USE {{
        about: {
          name: $url
          text_format: 'gfm'
          generator: 'src:openapi'
          generator_command: $generatorCommand
        },
        doctable: (http get $url|parse-from-swagger)
      }} $generatorCommand
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: url
      type: string
      description: ''
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:psql use
  summary: Queries a PostgreSQL database for definitions. All tables, views and functions that can be found are mounted as a doctable.
  kind: command
  description: |-
    Queries a PostgreSQL database for definitions. All tables, views and functions that can be found are mounted as a doctable.

    ### Examples:
    ```nushell
    # Parses database 'my_database'.'schema' for definitions
    > doc src:psql use 'public' '-d' 'my_database'
    ```
  source: |-
    def "doc src:psql use" [ schema: string ...args:any] {
      do --env $env.DOC_USE {
        def exec-query [query:string] {
          psql -c $query --csv ...$args
        }
        let tables = (
          exec-query (tables-query $schema)
          |from csv
          |each {|row|
            let table = $"($row.table_catalog).($row.table_schema)"
            {
              ns: $table
              name: $row.table_name
              description: ("```sql\n" +
                (pg_dump -t $"($row.table_schema).($row.table_name)" --schema-only ...$args
                |lines
                |where {|row| not (
                  ($row|str starts-with '--') or
                  ($row|str starts-with 'SELECT ') or
                  ($row|str starts-with 'SET ')
                )}
                |str join "\n"
                |str replace -a "\n\n" "\n"
                |str trim)
                + "\n```")
              kind: (match $row.table_type
                { "VIEW" => 'view',
                  _ => "table" }
              )
              columns: (columns-get $schema $args $row.table_name)
            }
          }
        )

        let columns = (columns-get $schema $args)

        let functions = (
          exec-query (functions-query $schema)
          |from csv
          |each {|row|
            let argtypes = (
              (($row.proargtypes|split row ' ') ++ [$row.prorettype])
              |each {into string}
            )
            let argtypeNames = (
              $argtypes
              |uniq
              |filter {$in != ''}
              |do {
                let types = $in

                exec-query (type-names-query $types)
                |from csv
                |each {|row|
                  { ($row.oid|into string): $row.typname }
                }
              }
              |reduce --fold {} {|a, b| $a|merge $b}
            )
            let argnames = (
              $row.proargnames
              |parse-psql-array
            ) ++ (0..|each {''}|take (($argtypes|length) - ($row.proargnames|length)))

            let args = (
              $argtypes|zip $argnames
              |each {|row|
                {
                  name: $row.1
                  type: ($argtypeNames|get -i $row.0)
                }
              }
            )

            {
              ns: $row.nspname
              name: $row.proname
              kind: 'function'
              signatures: [
                ($args|each { merge {kind: 'positional'} })
              ]
              description: ("```sql\n" + $row.prosrc + "\n```")
            }
          }
        )

        {
          about: {
            name: $"psql: ($schema) ($args|str join ' ')"
            text_format: 'markdown'
            language: 'sql'
          }
          doctable: (
            $tables ++ $columns ++ $functions
            |sort-by name
          )
        }

      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: schema
      type: string
      description: name of the schema to use
      optional: false
      default: null
      kind: positional
    - name: args
      type: any
      description: rest of the arguments are passed to psql/pg_dump as-is
      optional: true
      default: null
      kind: null
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:python use
  summary: Generates a doctable from Python `$module`. Invokes `$env.PKD_CONFIG.pythonCommand` to run a script using `python3` found using PATH. Doesn't install packages.
  kind: command
  description: |-
    Generates a doctable from Python `$module`. Invokes `$env.PKD_CONFIG.pythonCommand` to run a script using `python3` found using PATH. Doesn't install packages.

    ### Examples:
    ```nushell
    # Generates a doctable from a locally installed package
    > doc src:python use flask

    # Generates a doctable from a locally installed package
    > doc src:python use flask
    ```
  source: |-
    def "doc src:python use" [ module: string ] {
      let generatorCommand = $"src:python use ($module|to nuon)"

      do --env $env.DOC_USE {||
        let parsed = (
          do $env.PKD_CONFIG.pythonCommand $"($env.PKD_HOME)/doc/src:python.py" $module
          |lines
          |last
          |from json
        )

        let description = $parsed.about?.description?|default ''

        {
          about: ({
            name: $module
            text_format: 'rst'
            generator: 'src:python'
            generator_command: $generatorCommand
            language: 'python'
          }
          |merge $parsed.about
          |merge {
            description: (
              match ($parsed.packageMetadata?.descriptionContentType) {
                'text/x-rst' => { $description|pandoc -f rst -tgfm-raw_html }
                'text/markdown' => { $description|pandoc -f gfm -tgfm-raw_html }
                _ => { $description }
              }
            )
          }
          )
          doctable: (
            $parsed.doctable
          )
        }
      } $generatorCommand
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: module
      type: string
      description: ''
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:sqlite parse-from-db
  summary: Returns documentation for all tables, columns and indexes in a sqlite database.
  kind: command
  description: |-
    Returns documentation for all tables, columns and indexes in a sqlite database.

    `in` is a valid sqlite database.

    Example: open my-database.db|doc src:sqlite parse-from-db
  source: |-
    def "doc src:sqlite parse-from-db" [] {
      let $db = $in
      let tables = $db|query db 'SELECT type, name, sql FROM sqlite_master WHERE name not like "sqlite_%"'

      $tables|each {|tbl| {
        name: $tbl.name
        columns:
          ($db
            |query db $"PRAGMA table_info\(($tbl.name)\)"
            |each {|col| {
              name: $col.name
              type: $col.type
              default: $col.dflt_value
              nullable: ($col.notnull == 0)
              pk: ($col.pk == 1)
            }})
        source: $tbl.sql
        kind: (if ($tbl.type == 'index') { 'index' } else { 'table' })
      }}
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc src:sqlite use
  summary: Queries a sqlite database for its tables and selects the output as the current doctable
  kind: command
  description: |-
    Queries a sqlite database for its tables and selects the output as the current doctable

    `db` is a path to your sqlite database

    Example: doc src:sqlite use ./my-database.db
  source: |-
    def "doc src:sqlite use" [ db: any ] {
      do --env $env.DOC_USE {
        about: {
          name: $db
          text_format: 'text'
          generator: 'src:sqlite'
        }
        doctable: (open $db|parse-from-db)
      } $"src:sqlite use ($db)"
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: db
      type: any
      description: ''
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc tutor
  summary: Shows the pikadoc tutorial.
  kind: command
  description: Shows the pikadoc tutorial.
  source: |-
    def "doc tutor" [ page: int = 1 ] {
      do --env $env.DOC_USE $"($env.PKD_HOME)/user_guide.pkd"

      let tutorials = (
        $env.PKD_CURRENT.doctable
        |zip 0..
        |each {|row| $row.0|merge { '#': $row.1 }}
        |where {$in.name|str starts-with 'Tutorial'}
      )
      print (do --env $env.DOC ($tutorials|get ($page - 1)|get '#'))

      if ($page < ($tutorials|length)) {
        print ($"Page ($page)/($tutorials|length). Type `doc tutor ($page + 1)` to show the next page")
      } else {
        print ($"Page ($page)/($tutorials|length). For more information about specific commands, use `doc <command> --help`.")
      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: page
      type: int
      description: page to show
      optional: true
      default: 1
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc use
  summary: Sets the current doctable.
  kind: command
  description: |-
    Sets the current doctable.

    `docs` is either a file in the local filesystem or a pikadoc table.

    Examples

    # Use a docfile from local filesystem
      ```doc use my-doc-file.pkd```

    # Use a docfile downloaded from a server
      ```doc use (http get 'https://raw.githubusercontent.com/ArseAssassin/pikadoc/master/reference-docs.pkd'|from yaml)```
  source: |-
    def "doc use" [ docs: any command?: string ] {
      let type = $docs|describe
      let commandId = $command|default ''|cache command-to-id

      if ($type == 'string') {
        let file = (open $docs|from yaml)
        $env.PKD_CURRENT = {
          about: $file.0
          doctable: $file.1
        }
      } else if ($type == 'closure') {
        $env.PKD_CURRENT = if ($commandId in (cache|get name)) {
          open $"(cache repository)/($commandId)"|from msgpackz
        } else {
          let result = do $docs
          if ($result == null) {
            return
          } else {
            $result
          }
        }
      } else if ($type == 'nothing') {
        return
      } else {
        $env.PKD_CURRENT = $docs
      }

      if ($command != null) {
        cache-docs $commandId $env.PKD_CURRENT
      }

      if ($command != null) {
        $command
        |history doctables add
      }

      history symbols clear

      $"(pkd-doctable|length) symbols found\nUsing doctable ((pkd-about).name)~((pkd-about).version?)"
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: docs
      type: any
      description: ''
      optional: false
      default: null
      kind: positional
    - name: command
      type: string
      description: ''
      optional: true
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc version
  summary: Returns current pikadoc version
  kind: command
  description: Returns current pikadoc version
  source: |-
    def "doc version" [] {
      $env.PKD_VERSION
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return
- name: doc view-source
  summary: |-
    If symbol selected with `index` has sources available
    (`$symbol.defined_in.file` can be found in the filesystem), opens it
    for reading using `$env.PKD_CONFIG.pagerCommand`.
  kind: command
  description: |-
    If symbol selected with `index` has sources available
    (`$symbol.defined_in.file` can be found in the filesystem), opens it
    for reading using `$env.PKD_CONFIG.pagerCommand`.

    ### Examples:
    ```nushell
    # Show sources for symbol 0 using `less`
    doc view-source 0
    ```
  source: |-
    def "doc view-source" [ index: int ] {
      let symbol = pkd-doctable|get -i $index
      if ($symbol.source? != null) {
        $symbol.source|do (pkd-config pagerCommand)
      } else if ($symbol.defined_in?.file? != null and ($symbol.defined_in?.file?|path exists)) {
        do (pkd-config pagerCommand) $symbol.defined_in.file ($symbol.defined_in.line?|default 0)
      } else {
        print "Couldn't open sources for reading"
      }
    }
  examples: []
  signatures:
  - - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: input
    - name: index
      type: int
      description: index of the symbol
      optional: false
      default: null
      kind: positional
    - name: null
      type: any
      description: null
      optional: false
      default: null
      kind: return

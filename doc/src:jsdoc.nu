def parse-type [] {
  let value = $in
  {
    name:         $value.name?
    type:         $value.type?.names?.0?
    description:  $value.description?
    optional:     $value.optional?
    kind:         (if ($value.optional? == true) {
                    'optional'
                  } else {
                    'positional'
                  })
  }
}

# Parses json generated by jsdoc to generate a new doctable.
#
# `in`: should be a `jsdoc` generated JSON document
#
# Example: `doc use (npx jsdoc -X <path to source directory>|doc src:javascript parse-from-jsdoc)`
def parse-from-jsdoc [] {
  from json
  |where undocumented? != true and kind? != 'package' and kind? != 'member'
  |each {|row|
    let isConstructor = $row.kind? == 'class' and $row.params? != null
    {
      name: (if ($isConstructor) { $"new ($row.longname?)" } else { $row.longname? }),
      summary: ($row.description?|default ""|split row "."|get 0?),
      defined_in: {
        file: ($"($row.meta?.path?)/($row.meta?.filename?)")
        line: $row.meta?.lineno?
      }
      signatures: (if ($row.params? != null) {
        [(
          $row.params
          |each { parse-type }
          |append (if ($row.returns?.0? != null) {
            $row.returns.0|parse-type|merge { kind: 'return' }
          } else if ($isConstructor) {
            [{ name: null, type: $row.name?, description: null }]
          } else {
            []
          })
        )]
      })
      description: $row.description?
      kind: (
        if ($isConstructor) {
          'constructor'
        } else {
          $row.kind?
        }
      )
      source: $row.comment?
      examples: (
        $row.examples?
        |default []
      )
      ns: $row.memberof?
    }
  }
  |where {|row| ($"($row.summary?)($row.description?)"|str trim) != '' and not ($row.ns?|default ''|str starts-with '<anonymous>')}
}

# Attempts to detect whether given path contains any jsdoc annotations
# in .js files.
export def is-jsdoc-module [path:string] {
  cd $path
  (grep -qs '\\* @' **/*.js -m1 --exclude-dir=*.js|complete|get exit_code) == 0
}

# Parses doctable using `jsdoc -X`. For more details on how jsdoc is invoked, you can run:
# `less $"($env.PKD_HOME)/doc/jsdoc-run"`
#
# ### Examples:
# ```nu
# # Mount jsdocs for ramda.js
# > doc src:jsdoc use node_modules/ramda/src/
# ```
export def --env use [
  filepath:string # path to the directory jsdoc should be run against
] {
  if (not (is-jsdoc-module $filepath)) {
    return $"($filepath) doesn't seem to be a jsdoc module. See `doc src:jsdoc is-jsdoc-module` for details"
  }

  let absolutePath = $filepath|path expand
  let generatorCommand = $"src:jsdoc use ($absolutePath|to nuon)"
  do --env $env.DOC_USE {{
    about: {
      name: $filepath
      text_format: 'markdown'
      generator: 'src:jsdoc'
      generator_command: $generatorCommand
      language: 'javascript'
    }
    doctable: (do $env.PKD_CONFIG.npx_command '--yes' 'jsdoc' '-X' '-r' $absolutePath|parse-from-jsdoc)
  }} $generatorCommand
}